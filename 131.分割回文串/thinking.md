# 题目
给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。返回 s 所有可能的分割方案。
# 实例
输入: "aab"
输出:
[
  ["aa","b"],
  ["a","a","b"]
]

# 思考过程：
1. 观察输出，发现可以从开始不断分割第一个子串，判断是否是回文
2. 是回文则加入列表，并将剩下的字符串进行迭代，不是回文则下标加1，直到循环所有子串，动态规划
3. 状态：s(子串)，temp(前置子串)(在迭代中将这种temp传递下去，相当于回溯算法吧)
4. 选择：循环字符串，找出所有是回文的子串
5. 终止条件： s为空，即已找出所有子串，将temp加入全局列表

# 代码思路
1. 定义一个判断回文的函数 reverse（其实应该是partition），或者用 s[:p]==s[:p][::-1]
2. 迭代函数dp(s,temp),设定终止条件
3. 找出所有第一子串，判断是否回文
4. 不能用temp.append()  再接着传递temp，引用类型数据修改

# ps
迭代中，有每次迭代返回一个值，一般取大取小，或者每次迭代修改全局函数，亦或者每次迭代传递一个‘状态’，直到最后（回溯）
